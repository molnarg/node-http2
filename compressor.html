<!DOCTYPE html>
 
<html>
<head>
  <title>compressor.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="compressor.html">
                compressor.js
              </a>
            
              
              <a class="source" href="connection.html">
                connection.js
              </a>
            
              
              <a class="source" href="framer.html">
                framer.js
              </a>
            
              
              <a class="source" href="stream.html">
                stream.js
              </a>
            
              
              <a class="source" href="utils.html">
                utils.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>compressor.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>HTTP/2 compression is implemented by two <a href="http://nodejs.org/api/stream.html#stream_class_stream_transform">Transform Stream</a> subclasses that operate in
<a href="http://nodejs.org/api/stream.html#stream_new_stream_readable_options">object mode</a>: the Compressor and the Decompressor. These provide a layer between the
<a href="framer.html">framer</a> and the <a href="connection.html">connection handling component</a> that
generates/parses binary header data.</p>
<p>Compression functionality is separated from the integration part. The latter is implemented in
the last part of the file, while the larger part of the file is an implementation of the <a href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-00">HTTP/2
Header Compression</a> spec. Both Compressor and Decompressor store their compression related
state in CompressionContext objects. It is always accessed using methods that guarantee that
it remains in a valid state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> utils = require(<span class="string">'../lib/utils'</span>);
<span class="keyword">var</span> Transform = require(<span class="string">'stream'</span>).Transform;

exports.CompressionContext = CompressionContext;
exports.Decompressor = Decompressor;
exports.Compressor = Compressor;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h1>Compression Context</h1>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>A <code>CompressionContext</code> consists of the following tables:</p>
<ul>
<li>Header Table (<code>this._table</code>) that is limited in size (<code>this._limit</code>)</li>
<li>Reference Set (<code>this._reference</code>)</li>
<li>Working Set (<code>this._working</code>)</li>
</ul>
<p>Header Table and Reference Set entries are <code>[name, value]</code> pairs (where both are strings), while
Working Set entries are objects with two properties: <code>index</code> (a number) and <code>pair</code> (a pair).</p>
<p>There are only two methods that modifies the state of the tables: <code>reinitialize()</code> and
<code>execute(command)</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> DEFAULT_HEADER_TABLE_LIMIT = <span class="number">4096</span>;

<span class="function"><span class="keyword">function</span> <span class="title">CompressionContext</span><span class="params">(table, limit)</span> {</span>
  <span class="keyword">this</span>._table = table ? table.slice() : [];
  <span class="keyword">this</span>._limit = limit || DEFAULT_HEADER_TABLE_LIMIT;
  <span class="keyword">this</span>._reference = [];
  <span class="keyword">this</span>._working = [];
}</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>The <code>equal(pair1, pair2)</code> static method decides if two headers are considered equal. Name
comparison is case insensitive while value comparison is case sensitive.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>CompressionContext.equal = <span class="keyword">function</span>(pair1, pair2) {
  <span class="keyword">return</span> (pair1[<span class="number">0</span>].toLowerCase() === pair2[<span class="number">0</span>].toLowerCase()) &amp;&amp; (pair1[<span class="number">1</span>] === pair2[<span class="number">1</span>]);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p><code>getWorkingSet()</code> returns the current working set as an array of <code>[name, value]</code> pairs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>CompressionContext.prototype.getWorkingSet = <span class="function"><span class="keyword">function</span> <span class="title">getWorkingSet</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>._working.map(<span class="keyword">function</span>(entry) {
    <span class="keyword">return</span> entry.pair;
  });
};</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p><code>reinitialize()</code> must be called between parsing/generating header blocks.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>CompressionContext.prototype.reinitialize = <span class="function"><span class="keyword">function</span> <span class="title">reinitialize</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <ul>
<li>It first executes the steps needed to <em>end the processing of the previous block</em>.
The new reference set of headers is computed by removing from the working set all the headers
that are not present in the header table.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">this</span>._reference = <span class="keyword">this</span>._working.filter(<span class="keyword">function</span>(entry) {
    <span class="keyword">return</span> self._table.indexOf(entry.pair) !== -<span class="number">1</span>;
  }).map(<span class="keyword">function</span>(entry) {
    <span class="keyword">return</span> entry.pair;
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <ul>
<li>Then <em>prepares the processing of the next block</em>.
The reference set of headers is interpreted into the working set of headers: for each header
in the reference set, an entry is added to the working set, containing the header name, its
value, and its current index in the header table.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">this</span>._working = <span class="keyword">this</span>._reference.map(<span class="keyword">function</span>(pair) {
    <span class="keyword">var</span> index = self._table.indexOf(pair);
    <span class="keyword">return</span> { index: index, pair: pair };
  });
};</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p><code>execute(command)</code> executes the given command (<a href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-00#section-3.3">header representation</a>): updates the Header
Table and the Working Set.</p>
<p>The <em>JavaScript object representation</em> of a command:</p>
<pre><code>{
  name: String || Integer,  // string literal or index
  value: String || Integer, // string literal or index
  index: Integer            // -1       : no indexing
                            // 0 - ...  : substitution indexing
                            // Infinity : incremental indexing
}</code></pre>
<p>Examples:</p>
<pre><code>Indexed:
{ name: 2  , value: 2  , index: -1       }
Literal:
{ name: 2  , value: &#39;X&#39;, index: -1       } // without indexing
{ name: 2  , value: &#39;Y&#39;, index: Infinity } // incremental indexing
{ name: &#39;A&#39;, value: &#39;Z&#39;, index: 123      } // substitution indexing</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>CompressionContext.prototype.execute = <span class="function"><span class="keyword">function</span> <span class="title">execute</span><span class="params">(command)</span> {</span>
  <span class="keyword">var</span> index, pair;</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <ul>
<li>For an indexed representation, it checks whether the index is present in the working set.
If true, the corresponding entry is removed from the working set. If several entries correspond
to this encoded index, all these entries are removed from the working set. If the index is not
present in the working set, it is used to retrieve the corresponding header from the Header
Table, and a new entry is added to the working set representing this header.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (<span class="keyword">typeof</span> command.value === <span class="string">'number'</span>) {
    index = command.value;
    <span class="keyword">var</span> filtered = <span class="keyword">this</span>._working.filter(<span class="keyword">function</span>(entry) {
      <span class="keyword">return</span> entry.index !== index;
    });
    <span class="keyword">if</span> (filtered.length === <span class="keyword">this</span>._working.length) {
      pair = <span class="keyword">this</span>._table[index];
      <span class="keyword">this</span>._working.push({ index: index, pair: pair });
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>._working = filtered;
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <ul>
<li>For a literal representation, a new entry is added to the working set representing this
header. If the literal representation specifies that the header is to be indexed, the header is
added accordingly to the header table, and its index is included in the entry in the working
set. Otherwise, the entry in the working set contains an undefined index.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">else</span> {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> command.name === <span class="string">'number'</span>) {
      pair = [<span class="keyword">this</span>._table[command.name][<span class="number">0</span>], command.value];
    } <span class="keyword">else</span> {
      pair = [command.name, command.value];
    }

    <span class="keyword">if</span> (command.index !== -<span class="number">1</span>) {
      <span class="keyword">if</span> (command.index === <span class="literal">Infinity</span>) {
        <span class="keyword">this</span>._table.push(pair);
      } <span class="keyword">else</span> {
        <span class="keyword">this</span>._table.splice(command.index, <span class="number">1</span>, pair);
      }
      <span class="keyword">this</span>._enforceSizeBound();           <span class="comment">// TODO: The order of these two</span>
      index = <span class="keyword">this</span>._table.indexOf(pair);  <span class="comment">// TODO: operation is not well defined!</span>
    }

    <span class="keyword">this</span>._working.push({ index: index, pair: pair });
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p><code>generateAddCommand</code> tries to find a compact command (header representation) for the given
<code>[name, value]</code> pair that causes the decoder to add the given pair to the Working Set.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>CompressionContext.prototype.generateAddCommand = <span class="keyword">function</span>(pair) {
  <span class="keyword">var</span> equal = CompressionContext.equal.bind(<span class="literal">null</span>, pair);
  <span class="keyword">if</span> (<span class="keyword">this</span>.getWorkingSet().some(equal)) {
    <span class="keyword">return</span> <span class="literal">undefined</span>;
  }

  <span class="keyword">var</span> working = <span class="keyword">this</span>._working;
  <span class="function"><span class="keyword">function</span> <span class="title">shadowed</span><span class="params">(index)</span> {</span>
    <span class="keyword">return</span> working.some(<span class="keyword">function</span>(entry) {
      <span class="keyword">return</span> entry.index === index;
    });
  }

  <span class="keyword">var</span> full_match = <span class="keyword">this</span>._table.filter(equal);
  <span class="keyword">if</span> (full_match.length !== <span class="number">0</span>) {
    <span class="keyword">var</span> full_index = <span class="keyword">this</span>._table.indexOf(full_match[<span class="number">0</span>]);
    <span class="keyword">if</span> (!shadowed(full_index)) {
      <span class="keyword">return</span> {
        name: full_index,
        value: full_index,
        index: -<span class="number">1</span>
      };
    }
  }

  <span class="keyword">var</span> name = pair[<span class="number">0</span>].toLowerCase();
  <span class="keyword">var</span> name_match = <span class="keyword">this</span>._table.filter(<span class="keyword">function</span>(entry) {
    <span class="keyword">return</span> entry[<span class="number">0</span>].toLowerCase() === name;
  });
  <span class="keyword">if</span> (name_match.length !== <span class="number">0</span>) {
    <span class="keyword">var</span> name_index = <span class="keyword">this</span>._table.indexOf(name_match[<span class="number">0</span>]);
    <span class="keyword">if</span> (!shadowed(name_index)) {
      <span class="keyword">return</span> {
        name: name_index,
        value: pair[<span class="number">1</span>],
        index: name_index
      };
    }
  }

  <span class="keyword">return</span> {
    name: name,
    value: pair[<span class="number">1</span>],
    index: <span class="literal">Infinity</span>
  };
};</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p><code>generateRemoveCommand</code> generates a command (header representation) that causes the decoder to
drop the given pair from the Working Set.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>CompressionContext.prototype.generateRemoveCommand = <span class="keyword">function</span>(pair) {
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>._working.length; i++) {
    <span class="keyword">var</span> entry = <span class="keyword">this</span>._working[i];</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <ul>
<li>if the given header is in the Working Set, then the command is an Indexed Representation.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> (entry.pair === pair) {
      <span class="keyword">return</span> {
        name: entry.index,
        value: entry.index,
        index: -<span class="number">1</span>
      };
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <ul>
<li>if the given pair is not in the Working Set, it returns <code>undefined</code></li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">return</span> <span class="literal">undefined</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>The header table size can be bounded so as to limit the memory requirements.
The <code>_enforceSizeBound()</code> private method drops the entries that are over the limit
(<code>this._limit</code>).</p>
<p>The header table size is defined as the sum of the size of each entry of the table. The size
of an entry is the sum of the length in bytes of its name, of value&#39;s length in bytes and of
32 bytes (for accounting for the entry structure overhead).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>CompressionContext.prototype._enforceSizeBound = <span class="keyword">function</span>() {
  <span class="keyword">var</span> table = <span class="keyword">this</span>._table;
  <span class="keyword">var</span> size = <span class="number">0</span>;
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; table.length; i++) {
    <span class="keyword">if</span> (table[i].size === <span class="literal">undefined</span>) {
      table[i].size = <span class="keyword">new</span> Buffer(table[i][<span class="number">0</span>] + table[i][<span class="number">1</span>], <span class="string">'utf8'</span>).length + <span class="number">32</span>;
    }
    size += table[i].size;
  }
  <span class="keyword">while</span> (size &gt; <span class="keyword">this</span>._limit) {
    <span class="keyword">var</span> dropped = table.shift();
    size -= dropped.size;
  }
};</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <h1><a href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-00#section-3.4">Decompression process</a></h1>

            </div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>The decompression process is always done by a <code>Decompressor</code> object.</p>
<p>The compression related mutable state is stored in a contained <code>CompressionContext</code> object.
The initial value of it&#39;s Header Table depends on which side of the connection is it on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">Decompressor</span><span class="params">(type, log)</span> {</span>
  <span class="keyword">this</span>._log = log || utils.nolog;

  <span class="keyword">var</span> initial_table = (type === <span class="string">'REQUEST'</span>) ? CompressionContext.initialRequestTable
                                           : CompressionContext.initialResponseTable;
  <span class="keyword">this</span>._context = <span class="keyword">new</span> CompressionContext(initial_table);

  <span class="keyword">this</span>._initializeStream();
}
Decompressor.prototype = Object.create(Transform.prototype, { constructor: { value: Decompressor } });</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>The <code>decompress</code> method takes a buffer, and returns the decoded header set.</p>
<p>According to the spec, to ensure a correct decoding of a set of headers, the following steps or
equivalent ones MUST be executed by the decoder.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Decompressor.prototype.decompress = <span class="function"><span class="keyword">function</span> <span class="title">decompress</span><span class="params">(buffer)</span> {</span>
  <span class="keyword">this</span>._log.trace({ buffer: buffer }, <span class="string">'Starting header decompression'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <ul>
<li>First, upon starting the decoding of a new set of headers, the reference set of headers is
interpreted into the working set of headers</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">this</span>._context.reinitialize();</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <ul>
<li>Then, the header representations are processed in their order of occurrence in the frame.
The decoding process of the header representations are defined in the <code>execute(command)</code>
method of the <code>CompressionContext</code> class.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  buffer.cursor = <span class="number">0</span>;
  <span class="keyword">while</span> (buffer.cursor &lt; buffer.length) {
    <span class="keyword">this</span>._context.execute(Decompressor.header(buffer));
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <ul>
<li>When all the header representations have been processed, the working set contains all the
headers of the set of headers.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> pairs = <span class="keyword">this</span>._context.getWorkingSet();</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <ul>
<li>The working set entries are <code>[name, value]</code> pairs. As a last step, these are converted to the
usual header set format used in node.js: <code>{ name1: value1, name2: [value2, value3], ... }</code></li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> headers = {};
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pairs.length; i++) {
    <span class="keyword">var</span> name = pairs[i][<span class="number">0</span>];
    <span class="keyword">var</span> value = pairs[i][<span class="number">1</span>];
    <span class="keyword">if</span> (name <span class="keyword">in</span> headers) {
      <span class="keyword">if</span> (headers[name] <span class="keyword">instanceof</span> Array) {
        headers[name].push(value);
      } <span class="keyword">else</span> {
        headers[name] = [headers[name], value];
      }
    } <span class="keyword">else</span> {
      headers[name] = value;
    }
  }
  <span class="keyword">this</span>._log.debug({ headers: headers }, <span class="string">'Header decompression is done'</span>);
  <span class="keyword">return</span> headers;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h1>Compression process</h1>

            </div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>The decompression process is always done by a <code>Compressor</code> object.</p>
<p>The compression related mutable state is stored in a contained <code>CompressionContext</code> object.
The initial value of it&#39;s Header Table depends on which side of the connection is it on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="keyword">function</span> <span class="title">Compressor</span><span class="params">(type, log)</span> {</span>
  <span class="keyword">this</span>._log = log || utils.nolog;

  <span class="keyword">var</span> initial_table = (type === <span class="string">'REQUEST'</span>) ? CompressionContext.initialRequestTable
                                           : CompressionContext.initialResponseTable;
  <span class="keyword">this</span>._context = <span class="keyword">new</span> CompressionContext(initial_table);

  <span class="keyword">this</span>._initializeStream();
}
Compressor.prototype = Object.create(Transform.prototype, { constructor: { value: Compressor } });</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>The <code>compress</code> method takes a header set and returns an array of buffers containing the
encoded binary data.</p>
<p>The inverse of the decoding process goes follows:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Compressor.prototype.compress = <span class="function"><span class="keyword">function</span> <span class="title">compress</span><span class="params">(headers)</span> {</span>
  <span class="keyword">this</span>._log.debug({ headers: headers }, <span class="string">'Starting header compression'</span>);
  <span class="keyword">var</span> i;</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <ul>
<li>First, the usual node.js header set format (<code>{ name1: value1, name2: [value2, value3], ... }</code>)
has to be converted to <code>[name, value]</code> pairs.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> pairs = [];
  <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> headers) {
    <span class="keyword">var</span> value = headers[name];
    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Array) {
      <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; value.length; i++) {
        pairs.push([name, value[i]]);
      }
    } <span class="keyword">else</span> {
      pairs.push([name, value]);
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <ul>
<li>Before generating commands that make the working set equal to the generated pair set,
the reference set and the working set has to be reinitialized.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">this</span>._context.reinitialize();
  <span class="keyword">var</span> working = <span class="keyword">this</span>._context.getWorkingSet(), command, commands = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <ul>
<li>The first commands remove the unneeded headers from the working set.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; working.length; i++) {
    <span class="keyword">if</span> (!pairs.some(CompressionContext.equal.bind(<span class="literal">null</span>, working[i]))) {
      command = <span class="keyword">this</span>._context.generateRemoveCommand(working[i]);
      <span class="keyword">this</span>._context.execute(command);
      commands.push(command);
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <ul>
<li>Then the headers that are not present in the working set yet are added.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pairs.length; i++) {
    <span class="keyword">if</span> (!working.some(CompressionContext.equal.bind(<span class="literal">null</span>, pairs[i]))) {
      command = <span class="keyword">this</span>._context.generateAddCommand(pairs[i]);
      <span class="keyword">this</span>._context.execute(command);
      commands.push(command);
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <ul>
<li>The last step is the serialization of the generated commands.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">var</span> buffers = [];
  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; commands.length; i++) {
    buffers.push(Compressor.header(commands[i]));
  }

  <span class="keyword">var</span> buffer = utils.concat(Array.prototype.concat.apply([], buffers)); <span class="comment">// [[bufs]] -&gt; [bufs] -&gt; buf</span>

  <span class="keyword">this</span>._log.trace({ buffer: buffer }, <span class="string">'Header compression is done'</span>);
  <span class="keyword">return</span> buffer;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <h1><a href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-00#section-4">Detailed Format</a></h1>

            </div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <h2>Integer representation</h2>

            </div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>The algorithm to represent an integer I is as follows:</p>
<ol>
<li>If I &lt; 2^N - 1, encode I on N bits</li>
<li>Else, encode 2^N - 1 on N bits and do the following steps:<ol>
<li>Set I to (I - (2^N - 1)) and Q to 1</li>
<li>While Q &gt; 0<ol>
<li>Compute Q and R, quotient and remainder of I divided by 2^7</li>
<li>If Q is strictly greater than 0, write one 1 bit; otherwise, write one 0 bit</li>
<li>Encode R on the next 7 bits</li>
<li>I = Q</li>
</ol>
</li>
</ol>
</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>Compressor.integer = <span class="function"><span class="keyword">function</span> <span class="title">writeInteger</span><span class="params">(I, N)</span> {</span>
  <span class="keyword">var</span> limit = Math.pow(<span class="number">2</span>,N) - <span class="number">1</span>;
  <span class="keyword">if</span> (I &lt; limit) {
    <span class="keyword">return</span> [<span class="keyword">new</span> Buffer([I])];
  }

  <span class="keyword">var</span> bytes = [];
  <span class="keyword">if</span> (N !== <span class="number">0</span>) {
    bytes.push(limit);
  }
  I -= limit;

  <span class="keyword">var</span> Q = <span class="number">1</span>, R;
  <span class="keyword">while</span> (Q &gt; <span class="number">0</span>) {
    Q = Math.floor(I / <span class="number">128</span>);
    R = I % <span class="number">128</span>;

    <span class="keyword">if</span> (Q &gt; <span class="number">0</span>) {
      R += <span class="number">128</span>;
    }
    bytes.push(R);

    I = Q;
  }

  <span class="keyword">return</span> [<span class="keyword">new</span> Buffer(bytes)];
};</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>The inverse algorithm:</p>
<ol>
<li>Set I to the number coded on the lower N bits of the first byte</li>
<li>If I is smaller than 2^N - 1 then return I</li>
<li>Else the number is encoded on more than one byte, so do the following steps:<ol>
<li>Set M to 0</li>
<li>While returning with I<ol>
<li>Let B be the next byte (the first byte if N is 0)</li>
<li>Read out the lower 7 bits of B and multiply it with 2^M</li>
<li>Increase I with this number</li>
<li>Increase M by 7</li>
<li>Return I if the most significant bit of B is 0</li>
</ol>
</li>
</ol>
</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>Decompressor.integer = <span class="function"><span class="keyword">function</span> <span class="title">readInteger</span><span class="params">(buffer, N)</span> {</span>
  <span class="keyword">var</span> limit = Math.pow(<span class="number">2</span>,N) - <span class="number">1</span>;

  <span class="keyword">var</span> I = buffer[buffer.cursor] &amp; limit;
  <span class="keyword">if</span> (N !== <span class="number">0</span>) {
    buffer.cursor += <span class="number">1</span>;
  }

  <span class="keyword">if</span> (I === limit) {
    <span class="keyword">var</span> M = <span class="number">0</span>;
    <span class="keyword">do</span> {
      I += (buffer[buffer.cursor] &amp; <span class="number">127</span>) &lt;<span class="xml"><span class="tag">&lt; <span class="attribute">M</span>;
      <span class="attribute">M</span> += <span class="attribute">7</span>;
      <span class="attribute">buffer.cursor</span> += <span class="attribute">1</span>;
    } <span class="attribute">while</span> (<span class="attribute">buffer</span>[<span class="attribute">buffer.cursor</span> <span class="attribute">-</span> <span class="attribute">1</span>] &amp; <span class="attribute">128</span>);
  }

  <span class="attribute">return</span> <span class="attribute">I</span>;
};

</span></pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <h2>String literal representation</h2>

            </div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Literal <strong>strings</strong> can represent header names or header values.  They are encoded in two parts:</p>
<ol>
<li>The string length, defined as the number of bytes needed to store its UTF-8 representation,
is represented as an integer with a zero bits prefix.  If the string length is strictly less
than 128, it is represented as one byte.</li>
<li>The string value represented as a list of UTF-8 characters.</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>Compressor.string = <span class="function"><span class="keyword">function</span> <span class="title">writeString</span><span class="params">(str)</span> {</span>
  <span class="keyword">var</span> encoded_string = <span class="keyword">new</span> Buffer(str, <span class="string">'utf8'</span>);
  <span class="keyword">var</span> encoded_length = Compressor.integer(encoded_string.length, <span class="number">0</span>);
  <span class="keyword">return</span> encoded_length.concat(encoded_string);
};

Decompressor.string = <span class="function"><span class="keyword">function</span> <span class="title">readString</span><span class="params">(buffer)</span> {</span>
  <span class="keyword">var</span> length = Decompressor.integer(buffer, <span class="number">0</span>);
  <span class="keyword">var</span> str = buffer.toString(<span class="string">'utf8'</span>, buffer.cursor, buffer.cursor + length);
  buffer.cursor += length;
  <span class="keyword">return</span> str;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <h2><a href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-00#section-4.3">Header represenations</a></h2>

            </div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>The JavaScript object representation is described near the
<code>CompressionContext.prototype.execute()</code> method definition.</p>
<p><strong>All binary header representations</strong> start with a prefix signaling the representation type and
an index represented using prefix coded integers:</p>
<pre><code>  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 |        Index (7+)         |  Indexed Representation
+---+---------------------------+

+---+---+---+---+---+---+---+---+
| 0 | 1 | 1 |    Index (5+)     |  Literal w/o Indexing
+---+---+---+-------------------+

+---+---+---+---+---+---+---+---+
| 0 | 1 | 0 |    Index (5+)     |  Literal w/ Incremental Indexing
+---+---+---+-------------------+

+---+---+---+---+---+---+---+---+
| 0 | 0 |      Index (6+)       |  Literal w/ Substitution Indexing
+---+---+-----------------------+</code></pre>
<p>The <strong>Indexed Representation</strong> consists of the 1-bit prefix and the Index that is represented as
a 7-bit prefix coded integer and nothing else.</p>
<p>After the first bits, <strong>all literal representations</strong> specify the header name, either as a
pointer to the Header Table (Index) or a string literal. When the string literal representation
is used, the Index is set to 0 and the string literal starts at the second byte.</p>
<p>When using <strong>Substitution Indexing</strong>, a new index comes next represented as a 0-bit prefix
integer, specifying the record in the Header Table that needs to be replaced.</p>
<p>For <strong>all literal representations</strong>, the specification of the header value comes next. It is
always represented as a string.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> representations = {
  indexed             : { prefix: <span class="number">7</span>, pattern: <span class="number">0x80</span> },
  literal             : { prefix: <span class="number">5</span>, pattern: <span class="number">0x60</span> },
  literal_incremental : { prefix: <span class="number">5</span>, pattern: <span class="number">0x40</span> },
  literal_substitution: { prefix: <span class="number">6</span>, pattern: <span class="number">0x00</span> }
};

Compressor.header = <span class="function"><span class="keyword">function</span> <span class="title">writeString</span><span class="params">(header)</span> {</span>
  <span class="keyword">var</span> representation, buffers = [];

  <span class="keyword">if</span> (<span class="keyword">typeof</span> header.value === <span class="string">'number'</span>) {
    representation = representations.indexed;
  } <span class="keyword">else</span> <span class="keyword">if</span> (header.index === -<span class="number">1</span>) {
    representation = representations.literal;
  } <span class="keyword">else</span> <span class="keyword">if</span> (header.index === <span class="literal">Infinity</span>) {
    representation = representations.literal_incremental;
  } <span class="keyword">else</span> {
    representation = representations.literal_substitution;
  }

  <span class="keyword">if</span> (representation === representations.indexed) {
    buffers.push(Compressor.integer(header.value, representation.prefix));

  } <span class="keyword">else</span> {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> header.name === <span class="string">'number'</span>) {
      buffers.push(Compressor.integer(header.name + <span class="number">1</span>, representation.prefix));
    } <span class="keyword">else</span> {
      buffers.push(Compressor.integer(<span class="number">0</span>, representation.prefix));
      buffers.push(Compressor.string(header.name));
    }

    <span class="keyword">if</span> (representation === representations.literal_substitution) {
      buffers.push(Compressor.integer(header.index, <span class="number">0</span>));
    }

    buffers.push(Compressor.string(header.value));
  }

  buffers[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] |= representation.pattern;

  <span class="keyword">return</span> Array.prototype.concat.apply([], buffers); <span class="comment">// array of arrays of buffers -&gt; array of buffers</span>
};

Decompressor.header = <span class="function"><span class="keyword">function</span> <span class="title">readString</span><span class="params">(buffer)</span> {</span>
  <span class="keyword">var</span> representation, header = {};

  <span class="keyword">var</span> first_byte = buffer[buffer.cursor];
  <span class="keyword">if</span> (first_byte &amp; <span class="number">0x80</span>) {
    representation = representations.indexed;
  } <span class="keyword">else</span> <span class="keyword">if</span> (first_byte &amp; <span class="number">0x40</span>) {
    <span class="keyword">if</span> (first_byte &amp; <span class="number">0x20</span>) {
      representation = representations.literal;
    } <span class="keyword">else</span> {
      representation = representations.literal_incremental;
    }
  } <span class="keyword">else</span> {
    representation = representations.literal_substitution;
  }

  <span class="keyword">if</span> (representation === representations.indexed) {
    header.value = header.name = Decompressor.integer(buffer, representation.prefix);
    header.index = -<span class="number">1</span>;

  } <span class="keyword">else</span> {
    header.name = Decompressor.integer(buffer, representation.prefix) - <span class="number">1</span>;
    <span class="keyword">if</span> (header.name === -<span class="number">1</span>) {
      header.name = Decompressor.string(buffer);
    }

    <span class="keyword">if</span> (representation === representations.literal_substitution) {
      header.index = Decompressor.integer(buffer, <span class="number">0</span>);
    } <span class="keyword">else</span> <span class="keyword">if</span> (representation === representations.literal_incremental) {
      header.index = <span class="literal">Infinity</span>;
    } <span class="keyword">else</span> {
      header.index = -<span class="number">1</span>;
    }

    header.value = Decompressor.string(buffer);
  }

  <span class="keyword">return</span> header;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <h1>The compression layer</h1>

            </div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>This section describes the interaction between the compressor/decompressor and the rest of the
HTTP/2 implementation. The Compressor and the Decompressor makes up a layer between the
<a href="framer.html">framer</a> and the <a href="connection.html">connection handling component</a>. They let most
frames pass through, except HEADERS and PUSH_PROMISE frames. They convert the frames between
these two representations:</p>
<pre><code>{                                   {
 type: &#39;HEADERS&#39;,                    type: &#39;HEADERS&#39;,
 flags: {},                          flags: {},
 stream: 1,               &lt;===&gt;      stream: 1,
 headers: {                          data: Buffer
  N1: &#39;V1&#39;,                         }
  N2: [&#39;V1&#39;, &#39;V2&#39;, ...],
  // ...
 }
}</code></pre>
<p>There are possibly several binary frame that belong to a single non-binary frame.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">var</span> MAX_HTTP_PAYLOAD_SIZE = <span class="number">16383</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>The Compressor transform stream is basically stateless.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Compressor.prototype._initializeStream = <span class="function"><span class="keyword">function</span> <span class="title">_initializeStream</span><span class="params">()</span> {</span>
  Transform.call(<span class="keyword">this</span>, { objectMode: <span class="literal">true</span> });
};

Compressor.prototype._transform = <span class="function"><span class="keyword">function</span> <span class="title">_transform</span><span class="params">(frame, encoding, done)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>When it receives a HEADERS or PUSH_PROMISE frame</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (frame.type === <span class="string">'HEADERS'</span> || frame.type === <span class="string">'PUSH_PROMISE'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <ul>
<li>it generates a header block using the compress method</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> buffer = <span class="keyword">this</span>.compress(frame.headers);</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <ul>
<li>cuts the header block into <code>chunks</code> that are not larger than <code>MAX_HTTP_PAYLOAD_SIZE</code></li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> chunks = utils.cut(buffer, MAX_HTTP_PAYLOAD_SIZE);</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <ul>
<li>for each <code>chunk</code>, it pushes out a <code>chunk_frame</code> that is identical to the original, except
the <code>data</code> property which holds the given chunk and the END_HEADERS/END_PUSH_STREAM flag
that marks the last frame</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; chunks.length; i++) {
      <span class="keyword">var</span> flags = utils.clone(frame.flags);
      flags[<span class="string">'END_'</span> + frame.type] = (i === chunks.length - <span class="number">1</span>);
      <span class="keyword">this</span>.push({
        type: frame.type,
        flags: flags,
        stream: frame.stream,
        priority: frame.priority,
        data: chunks[i]
      });
    }
  }

  done();
};</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>The Decompressor is a stateful transform stream, since it has to collect multiple frames first,
and the decoding comes after unifying the payload of those frames.</p>
<p>If there&#39;s a frame in progress, <code>this._in_progress</code> is <code>true</code>. The frames are collected in
<code>this._frames</code>, and the type of the frame and the stream identifier is stored in <code>this._type</code>
and <code>this._stream</code> respectively.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Decompressor.prototype._initializeStream = <span class="function"><span class="keyword">function</span> <span class="title">_initializeStream</span><span class="params">()</span> {</span>
  Transform.call(<span class="keyword">this</span>, { objectMode: <span class="literal">true</span> });
  <span class="keyword">this</span>._in_progress = <span class="literal">false</span>;
  <span class="keyword">this</span>._type = <span class="literal">undefined</span>;
  <span class="keyword">this</span>._stream = <span class="literal">undefined</span>;
  <span class="keyword">this</span>._frames = <span class="literal">undefined</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>When a <code>frame</code> arrives</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>Decompressor.prototype._transform = <span class="function"><span class="keyword">function</span> <span class="title">_transform</span><span class="params">(frame, encoding, done)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <ul>
<li>and the collection process is already <code>_in_progress</code>, the frame is simply stored, except if
it&#39;s an illegal frame</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (<span class="keyword">this</span>._in_progress) {
    <span class="keyword">if</span> (frame.type !== <span class="keyword">this</span>._type || frame.stream !== <span class="keyword">this</span>._stream) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'A series of header frames must not be interleaved with other frames!'</span>);
    }
    <span class="keyword">this</span>._frames.push(frame);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <ul>
<li>and the collection process is not <code>_in_progress</code>, but the new frame&#39;s type is HEADERS or
PUSH_PROMISE, a new collection process begins</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">else</span> <span class="keyword">if</span> (frame.type === <span class="string">'HEADERS'</span> || frame.type === <span class="string">'PUSH_PROMISE'</span>) {
    <span class="keyword">this</span>._in_progress = <span class="literal">true</span>;
    <span class="keyword">this</span>._type = frame.type;
    <span class="keyword">this</span>._stream = frame.stream;
    <span class="keyword">this</span>._frames = [frame];
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <ul>
<li>otherwise, the frame is forwarded without taking any action</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">else</span> {
    <span class="keyword">this</span>.push(frame);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>When the frame signals that it&#39;s the last in the series, the header block chunks are
concatenated, the headers are decompressed, and a new frame gets pushed out with the
decompressed headers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="keyword">if</span> (<span class="keyword">this</span>._in_progress &amp;&amp; (frame.flags.END_HEADERS || frame.flags.END_PUSH_PROMISE)) {
    <span class="keyword">var</span> buffer = utils.concat(<span class="keyword">this</span>._frames.map(<span class="keyword">function</span>(frame) {
      <span class="keyword">return</span> frame.data;
    }));
    <span class="keyword">var</span> headers = <span class="keyword">this</span>.decompress(buffer);
    <span class="keyword">this</span>.push({
      type: frame.type,
      flags: frame.flags,
      stream: frame.stream,
      priority: frame.priority,
      headers: headers
    });
    <span class="keyword">this</span>._in_progress = <span class="literal">false</span>;
  }

  done();
};</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <h1><a href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-00#appendix-A">Initial header names</a></h1>

            </div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>CompressionContext.initialRequestTable  = [
  [ <span class="string">':scheme'</span>                     , <span class="string">'http'</span>  ],
  [ <span class="string">':scheme'</span>                     , <span class="string">'https'</span> ],
  [ <span class="string">':host'</span>                       , <span class="string">''</span>      ],
  [ <span class="string">':path'</span>                       , <span class="string">'/'</span>     ],
  [ <span class="string">':method'</span>                     , <span class="string">'get'</span>   ],
  [ <span class="string">'accept'</span>                      , <span class="string">''</span>      ],
  [ <span class="string">'accept-charset'</span>              , <span class="string">''</span>      ],
  [ <span class="string">'accept-encoding'</span>             , <span class="string">''</span>      ],
  [ <span class="string">'accept-language'</span>             , <span class="string">''</span>      ],
  [ <span class="string">'cookie'</span>                      , <span class="string">''</span>      ],
  [ <span class="string">'if-modified-since'</span>           , <span class="string">''</span>      ],
  [ <span class="string">'keep-alive'</span>                  , <span class="string">''</span>      ],
  [ <span class="string">'user-agent'</span>                  , <span class="string">''</span>      ],
  [ <span class="string">'proxy-connection'</span>            , <span class="string">''</span>      ],
  [ <span class="string">'referer'</span>                     , <span class="string">''</span>      ],
  [ <span class="string">'accept-datetime'</span>             , <span class="string">''</span>      ],
  [ <span class="string">'authorization'</span>               , <span class="string">''</span>      ],
  [ <span class="string">'allow'</span>                       , <span class="string">''</span>      ],
  [ <span class="string">'cache-control'</span>               , <span class="string">''</span>      ],
  [ <span class="string">'connection'</span>                  , <span class="string">''</span>      ],
  [ <span class="string">'content-length'</span>              , <span class="string">''</span>      ],
  [ <span class="string">'content-md5'</span>                 , <span class="string">''</span>      ],
  [ <span class="string">'content-type'</span>                , <span class="string">''</span>      ],
  [ <span class="string">'date'</span>                        , <span class="string">''</span>      ],
  [ <span class="string">'expect'</span>                      , <span class="string">''</span>      ],
  [ <span class="string">'from'</span>                        , <span class="string">''</span>      ],
  [ <span class="string">'if-match'</span>                    , <span class="string">''</span>      ],
  [ <span class="string">'if-none-match'</span>               , <span class="string">''</span>      ],
  [ <span class="string">'if-range'</span>                    , <span class="string">''</span>      ],
  [ <span class="string">'if-unmodified-since'</span>         , <span class="string">''</span>      ],
  [ <span class="string">'max-forwards'</span>                , <span class="string">''</span>      ],
  [ <span class="string">'pragma'</span>                      , <span class="string">''</span>      ],
  [ <span class="string">'proxy-authorization'</span>         , <span class="string">''</span>      ],
  [ <span class="string">'range'</span>                       , <span class="string">''</span>      ],
  [ <span class="string">'te'</span>                          , <span class="string">''</span>      ],
  [ <span class="string">'upgrade'</span>                     , <span class="string">''</span>      ],
  [ <span class="string">'via'</span>                         , <span class="string">''</span>      ],
  [ <span class="string">'warning'</span>                     , <span class="string">''</span>      ]
];

CompressionContext.initialResponseTable = [
  [ <span class="string">':status'</span>                     , <span class="string">'200'</span>   ],
  [ <span class="string">'age'</span>                         , <span class="string">''</span>      ],
  [ <span class="string">'cache-control'</span>               , <span class="string">''</span>      ],
  [ <span class="string">'content-length'</span>              , <span class="string">''</span>      ],
  [ <span class="string">'content-type'</span>                , <span class="string">''</span>      ],
  [ <span class="string">'date'</span>                        , <span class="string">''</span>      ],
  [ <span class="string">'etag'</span>                        , <span class="string">''</span>      ],
  [ <span class="string">'expires'</span>                     , <span class="string">''</span>      ],
  [ <span class="string">'last-modified'</span>               , <span class="string">''</span>      ],
  [ <span class="string">'server'</span>                      , <span class="string">''</span>      ],
  [ <span class="string">'set-cookie'</span>                  , <span class="string">''</span>      ],
  [ <span class="string">'vary'</span>                        , <span class="string">''</span>      ],
  [ <span class="string">'via'</span>                         , <span class="string">''</span>      ],
  [ <span class="string">'access-control-allow-origin'</span> , <span class="string">''</span>      ],
  [ <span class="string">'accept-ranges'</span>               , <span class="string">''</span>      ],
  [ <span class="string">'allow'</span>                       , <span class="string">''</span>      ],
  [ <span class="string">'connection'</span>                  , <span class="string">''</span>      ],
  [ <span class="string">'content-disposition'</span>         , <span class="string">''</span>      ],
  [ <span class="string">'content-encoding'</span>            , <span class="string">''</span>      ],
  [ <span class="string">'content-language'</span>            , <span class="string">''</span>      ],
  [ <span class="string">'content-location'</span>            , <span class="string">''</span>      ],
  [ <span class="string">'content-md5'</span>                 , <span class="string">''</span>      ],
  [ <span class="string">'content-range'</span>               , <span class="string">''</span>      ],
  [ <span class="string">'link'</span>                        , <span class="string">''</span>      ],
  [ <span class="string">'location'</span>                    , <span class="string">''</span>      ],
  [ <span class="string">'p3p'</span>                         , <span class="string">''</span>      ],
  [ <span class="string">'pragma'</span>                      , <span class="string">''</span>      ],
  [ <span class="string">'proxy-authenticate'</span>          , <span class="string">''</span>      ],
  [ <span class="string">'refresh'</span>                     , <span class="string">''</span>      ],
  [ <span class="string">'retry-after'</span>                 , <span class="string">''</span>      ],
  [ <span class="string">'strict-transport-security'</span>   , <span class="string">''</span>      ],
  [ <span class="string">'trailer'</span>                     , <span class="string">''</span>      ],
  [ <span class="string">'transfer-encoding'</span>           , <span class="string">''</span>      ],
  [ <span class="string">'warning'</span>                     , <span class="string">''</span>      ],
  [ <span class="string">'www-authenticate'</span>            , <span class="string">''</span>      ]
];</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
